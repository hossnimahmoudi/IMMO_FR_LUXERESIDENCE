#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Utility methods

from __future__ import unicode_literals

import netifaces
import phonenumbers
from phonenumbers.phonenumberutil import region_code_for_country_code, number_type
from phonenumbers import carrier
from scrapy.utils.project import get_project_settings
from scrapy.exceptions import NotConfigured
import time
from geopy.geocoders import Nominatim
import geopy
from geopy.distance import VincentyDistance
from iso3166 import countries
import gettext
import pycountry
import re
try:
    import urlparse
    from urllib import urlencode
except: # For Python 3
    import urllib.parse as urlparse
    from urllib.parse import urlencode
import nvector
import math

import hashlib
import weakref
from scrapy.utils.python import to_bytes
from w3lib.url import canonicalize_url

import logging
logger = logging.getLogger(__name__)

# SETTINGS
NEUKOLLN_PHONE_COMMON_DELIMITERS = "NEUKOLLN_PHONE_COMMON_DELIMITERS"


def get_mandatory_variable_from_settings(key):
    """
    It returns the value of the variable which MUST be set in the settings.py file.
    Otherwise it raises a proper exception.
    """
    settings = get_project_settings()
    value = settings.get(key)
    if not value or (len(value) == 0):
        raise NotConfigured("'%s' not set or empty. Please check the settings.py file" % key)
    return value


def timestamp_to_date(ts):
    """
    Converting unix timestamp string to readable date in Python
    http://stackoverflow.com/questions/3682748/converting-unix-timestamp-string-to-readable-date-in-python
    """
    try:
        return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(int(ts))) if ts else None
    except Exception, e:
        # [ERROR] Alert user
        logger.error("[TIMESTAMP_TO_DATE][NEUKOLLN] Unable to format the date "
                     "for the given timestamp: %s\nException: %s" % (str(ts), str(e)))


def clean_text(txt):
    """Remove line breaks or multiple spaces"""
    txt = txt.replace('\t', ' ').replace('\n', ' ').replace('\r', ' ')  # remove line breaks
    txt = ' '.join(txt.split())  # replace multiple spaces by single one
    return txt


def get_txt_from_element(el):
    """Return txt from element"""
    if not el:
        return None
    txt = el.get_text(strip=True)
    return clean_text(txt)


def cast_float(f, decimals=2):
    """Return float with only 2 decimals by default"""

    if isinstance(f, basestring):
        # First, clean input if it's a string
        f = f.replace(u'\xa0', '')
        f = f.replace(",", ".")

    # Then, cast to float
    f = float(f) if (f is not None) else None

    # Round float with only 2 decimals (number of decimals by default)
    # return "%.2f" % f if f else None
    # f = round(f, decimals) if f else None
    f = round(f, decimals) if (f is not None) else None

    # Set as None if equals to zero
    # f = f if (f != float(0)) else None

    return f


def cast_int(i):
    """Return int"""

    if isinstance(i, str):
        # First, clean input if it's a string
        i = i.replace(u'\xa0', '')
        i = i.replace(",", ".")

    # Then, cast to float
    i = float(i) if i else None

    # then to int
    i = int(i) if i else None

    return i


def get_inet_ips():
    """
    Return all public IPs available on the machine
        http://stackoverflow.com/questions/270745/how-do-i-determine-all-of-my-ip-addresses-when-i-have-multiple-nics
    """
    return list([
                    netifaces.ifaddresses(iface)[netifaces.AF_INET][0]['addr']
                    for iface in netifaces.interfaces()
                    if (netifaces.AF_INET in netifaces.ifaddresses(iface)) and ("lo" not in iface)
                    ])


def parse_phone_with_lib(pn):
    """Clean phone using the library phonenumber"""
    if pn:
        # Check if parsed phone is valid
        if phonenumbers.is_valid_number(pn) and phonenumbers.is_possible_number(pn):
            # Get country from phone
            phone_country = region_code_for_country_code(pn.country_code)
            phone = phonenumbers.format_number(pn, phonenumbers.PhoneNumberFormat.INTERNATIONAL)
            phone = str(phone).replace(' ', '').replace("+", "00")
            return phone, phone_country


def parse_phone(phone, phone_country):
    """Parse, clean and detect phone using the library phonenumber"""
    if not phone:
        return None, None

    if not phone_country:
        # [ERROR] Alert user
        logger.error("[PARSE_PHONE][NEUKOLLN] Unable to parse the phone without a default phone code country given as a"
                     " parameter!")
        return phone, None

    try:
        # Parse
        pn = phonenumbers.parse(phone, phone_country)
        res = parse_phone_with_lib(pn)
        if res:
            return res
    except:
        pass

    # too long?
    # several phones?
    return parse_multiple_phones(phone, phone_country)


def parse_multiple_phones(phone, phone_country):
    """Suppose there are multiple phones to parse"""
    common_delimiters = ["-", ",", "_", ";", ":", "|", "/", "OU", " "]  # no dot, space last
    common_delimiters = get_project_settings().get(NEUKOLLN_PHONE_COMMON_DELIMITERS, common_delimiters)

    for delimiter in common_delimiters:
        phones = set()
        phones_countries = set()

        # try to split by dash...
        if len(phone.split(delimiter)):
            for el in phone.split(delimiter):
                try:
                    # Parse
                    pn = phonenumbers.parse(el, phone_country)
                    res = parse_phone_with_lib(pn)
                    if res:
                        phones.add(res[0])
                        phones_countries.add(res[1])
                except:
                    pass

            if len(phones):
                # Return the lists of phones and countries
                # Order by fix phone number first, then mobile
                return sorted(list(phones), key=lambda phone: carrier._is_mobile(
                    number_type(phonenumbers.parse(phone, phone_country))), reverse=False), list(phones_countries)

    # Return the initial inputs
    # return phone, phone_country

    # Don't return wrong phone numbers input
    return None, None


def get_address_dict_from_coordinates(lat, lon):
    """
    Return address dict from coordinates using geopy

    Interesting keys are:
        house_number, road, postcode, city, country

    Geopy github:
        https://github.com/geopy/geopy
    Geopy pypi:
        https://pypi.python.org/pypi/geopy

    Carefull with the number of requests!!!
        Example: with website www.homelidays.com" HTTP Error 429: Too Many Request"
                 ~100 errors for ~50.000 crawled items / API requests - (DOWNLOAD_DELAY=0.25)
    """
    try:
        geolocator = Nominatim()
        location = geolocator.reverse("{latitude}, {longitude}".format(latitude=lat, longitude=lon))
        if location and location.raw:
            return location.raw['address']
    except Exception, e:
        logger.error(str(e))

def get_iso3166_alpha2(country_txt):
    """
    Return iso3166 alpha2 code of a country_txt

    Geopy github:
        https://github.com/deactivated/python-iso3166
    Geopy pypi:
        https://pypi.python.org/pypi/iso3166

    Carefull ==> input in english works better
    """
    try:
        country_txt = clean_text(country_txt)  # ensure text is "clean"
        if not country_txt:
            return
        return countries.get(country_txt).alpha2
    except Exception, e:
        logger.error(str(e))

def get_iso3166_alpha2_from_fr_input(country_txt):
    """
    Return iso3166 alpha2 code of a country_txt

    Geopy github:
        https://github.com/deactivated/python-iso3166
    Geopy pypi:
        https://pypi.python.org/pypi/iso3166

    Carefull ==> input in english works better
    """
    try:
        country_txt = clean_text(country_txt)  # ensure text is "clean"
        if not country_txt:
            return
        gettext.translation('iso3166', pycountry.LOCALES_DIR, languages=['fr']).install()
        return ''.join([country.alpha_2 for country in pycountry.countries if _(country.name) == country_txt])
    except Exception, e:
        logger.error(str(e))


def find_urls_in_text(description):
    """Find urls (like website) in ad description"""
    description = clean_text(description)  # ensure text is "clean"
    if not description:
        return
    urls = re.findall('https?://\S+|www\.\S+', description)
    if urls:
        return ",".join(urls)


def find_emails_in_text(description):
    """Find emails in ad description"""
    description = clean_text(description)  # ensure text is "clean"
    if not description:
        return
    emails = re.findall(r'[\w\.-]+@[\w\.-]+', description)
    if emails:
        return ",".join(emails)


def find_phones_in_text(description, default_phone_country):
    """Find / Extract phone(s) within an ad description using the Python lib PHONENUMBERS \Ã´/ this lib rocks!!!"""
    description = clean_text(description)  # ensure text is "clean"
    if not description:
        return
    matches = phonenumbers.PhoneNumberMatcher(description, default_phone_country)
    phones = []
    if matches:
        for match in matches:
            try:
                phone = phonenumbers.format_number(match.number, phonenumbers.PhoneNumberFormat.INTERNATIONAL)
                phones.append(phone)
            except Exception, e:
                logger.error(str(e))
    return ",".join(phones)


def get_query_params(url):
    """Return dictionary of query parameters"""
    try:
        return urlparse.parse_qs(urlparse.urlparse(url).query, True)
    except Exception, e:
        logger.error(str(e))


def update_query_param(url, key, value):
    """
    Update query paramaters with correct value
    Useful to bisect...

    http://stackoverflow.com/questions/2506379/add-params-to-given-url-in-python
    """
    try:
        # Split url
        url_parts = list(urlparse.urlparse(url))

        # Retrieve query parameters as dictionary
        query_params = dict(urlparse.parse_qsl(url_parts[4]))
        query_params[key] = value  # <===== update value of the query parameter

        # Update all query parameters
        url_parts[4] = urlencode(query_params)

        # Return url
        return urlparse.urlunparse(url_parts)

    except Exception, e:
        logger.error((str(e)))


def find_french_zipcode(address):
    """Find / Extract zipcode in address text"""
    if not address:
        return

    reg = re.compile('^.*(?P<zipcode>\d{5}).*$')
    match = reg.match(address)

    if match:
        # there is a zip code
        return match.groupdict()['zipcode']


def get_midpoint(latitude1, longitude1, latitude2, longitude2):
    """
    Useful for quadtree search (map)

    Using nvector library
        https://pypi.python.org/pypi/nvector

    Code from:
        http://gis.stackexchange.com/questions/55236/what-python-package-to-use-to-calculate-midpoint

        "Given two Vertices, return the geodetic midpoint of the great circle arc between them, on the WGS84 ellipsoid. Uses nvector."
        "See http://nvector.readthedocs.org/en/latest/src/overview.html?highlight=midpoint#description"
    """
    wgs84 = nvector.FrameE(name='WGS84')
    n_EB_E_t0 = wgs84.GeoPoint(float(latitude1), float(longitude1), degrees=True).to_nvector()
    n_EB_E_t1 = wgs84.GeoPoint(float(latitude2), float(longitude2), degrees=True).to_nvector()
    path = nvector.GeoPath(n_EB_E_t0, n_EB_E_t1)
    halfway = 0.5
    g_EB_E_ti = path.interpolate(halfway).to_geo_point()
    lat_ti, lon_ti = g_EB_E_ti.latitude_deg, g_EB_E_ti.longitude_deg
    return float(lat_ti), float(lon_ti)


def get_p2_from_p1(lat1, lon1, b, d):
    """
    Useful for hexagonal packing arrangement (density ~ 0.91)
    http://stackoverflow.com/questions/7222382/get-lat-long-given-current-point-distance-and-bearing
    https://en.wikipedia.org/wiki/Circle_packing
    """
    # given: lat1, lon1, b = bearing in degrees, d = distance in kilometers
    origin = geopy.Point(lat1, lon1)
    destination = VincentyDistance(kilometers=d).destination(origin, b)
    lat2, lon2 = destination.latitude, destination.longitude
    return lat2, lon2


def splash_custom_fingerprint(request, include_headers=None):
    if include_headers:
        include_headers = tuple(to_bytes(h.lower())
                                 for h in sorted(include_headers))
    #_fingerprint_cache = weakref.WeakKeyDictionary()
    cache = weakref.WeakKeyDictionary().setdefault(request, {})
    if include_headers not in cache:
        fp = hashlib.sha1()
        fp.update(to_bytes("GET"))#request.method))
        fp.update(to_bytes(canonicalize_url(request.meta['splash']['args']['url'])))
        fp.update(b'')#request.body or b'')
        if include_headers:
            for hdr in include_headers:
                if hdr in request.headers:
                    fp.update(hdr)
                    for v in request.headers.getlist(hdr):
                        fp.update(v)
        cache[include_headers] = fp.hexdigest()
    return cache[include_headers]